{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydantic-redis","text":"<p>A simple declarative ORM for redis based on pydantic</p>"},{"location":"#features","title":"Features","text":"<ol> <li>A subclass-able <code>Model</code> class to create Object Relational Mapping to redis hashes</li> <li>A redis <code>Store</code> class to mutate and query <code>Model</code>'s registered in it</li> <li>A <code>RedisConfig</code> class to pass to the <code>Store</code> constructor to connect to a redis instance</li> <li>A synchronous <code>syncio</code> and an asynchronous <code>asyncio</code> interface to the above classes</li> </ol>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install pydantic-redis\n\n---&gt; 100%\n</code></pre>"},{"location":"#synchronous-example","title":"Synchronous Example","text":""},{"location":"#create-it","title":"Create it","text":"<ul> <li>Create a file <code>main.py</code> with:</li> </ul> <pre><code>import pprint\nfrom datetime import date\nfrom typing import Tuple, List\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n    store.register_model(Author)\n\n    authors = {\n        \"charles\": Author(name=\"Charles Dickens\", active_years=(1220, 1280)),\n        \"jane\": Author(name=\"Jane Austen\", active_years=(1580, 1640)),\n    }\n\n    books = [\n        Book(\n            title=\"Oliver Twist\",\n            author=authors[\"charles\"],\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        ),\n        Book(\n            title=\"Great Expectations\",\n            author=authors[\"charles\"],\n            published_on=date(year=1220, month=4, day=4),\n            rating=5,\n            tags=[\"Classic\"],\n        ),\n        Book(\n            title=\"Jane Eyre\",\n            author=authors[\"charles\"],\n            published_on=date(year=1225, month=6, day=4),\n            in_stock=False,\n            rating=3.4,\n            tags=[\"Classic\", \"Romance\"],\n        ),\n        Book(\n            title=\"Wuthering Heights\",\n            author=authors[\"jane\"],\n            published_on=date(year=1600, month=4, day=4),\n            rating=4.0,\n            tags=[\"Classic\", \"Romance\"],\n        ),\n    ]\n\n    Book.insert(books, life_span_seconds=3600)\n    all_books = Book.select()\n    paginated_books = Book.select(skip=2, limit=2)\n    paginated_books_with_few_fields = Book.select(\n        columns=[\"author\", \"in_stock\"], skip=2, limit=2\n    )\n    print(\"All:\")\n    pp.pprint(all_books)\n    print(\"\\nPaginated:\")\n    pp.pprint(paginated_books)\n    print(\"\\nPaginated but with few fields:\")\n    pp.pprint(paginated_books_with_few_fields)\n</code></pre>"},{"location":"#run-it","title":"Run it","text":"<p>Run the example with:</p> <pre><code>$ python main.py\nAll:\n[   Book(title='Wuthering Heights', author=Author(name='Jane Austen', active_years=(1580, 1640)), rating=4.0, published_on=datetime.date(1600, 4, 4), tags=['Classic', 'Romance'], in_stock=True),\n    Book(title='Oliver Twist', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False),\n    Book(title='Jane Eyre', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=3.4, published_on=datetime.date(1225, 6, 4), tags=['Classic', 'Romance'], in_stock=False),\n    Book(title='Great Expectations', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=5.0, published_on=datetime.date(1220, 4, 4), tags=['Classic'], in_stock=True)]\n\nPaginated:\n[   Book(title='Jane Eyre', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=3.4, published_on=datetime.date(1225, 6, 4), tags=['Classic', 'Romance'], in_stock=False),\n    Book(title='Wuthering Heights', author=Author(name='Jane Austen', active_years=(1580, 1640)), rating=4.0, published_on=datetime.date(1600, 4, 4), tags=['Classic', 'Romance'], in_stock=True)]\n\nPaginated but with few fields:\n[   {   'author': Author(name='Charles Dickens', active_years=(1220, 1280)),\n        'in_stock': False},\n    {   'author': Author(name='Jane Austen', active_years=(1580, 1640)),\n        'in_stock': True}]\n</code></pre>"},{"location":"#asynchronous-example","title":"Asynchronous Example","text":""},{"location":"#create-it_1","title":"Create it","text":"<ul> <li>Create a file <code>main.py</code> with:</li> </ul> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import Tuple, List\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def run_async():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n    store.register_model(Author)\n\n    authors = {\n        \"charles\": Author(name=\"Charles Dickens\", active_years=(1220, 1280)),\n        \"jane\": Author(name=\"Jane Austen\", active_years=(1580, 1640)),\n    }\n\n    books = [\n        Book(\n            title=\"Oliver Twist\",\n            author=authors[\"charles\"],\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        ),\n        Book(\n            title=\"Great Expectations\",\n            author=authors[\"charles\"],\n            published_on=date(year=1220, month=4, day=4),\n            rating=5,\n            tags=[\"Classic\"],\n        ),\n        Book(\n            title=\"Jane Eyre\",\n            author=authors[\"charles\"],\n            published_on=date(year=1225, month=6, day=4),\n            in_stock=False,\n            rating=3.4,\n            tags=[\"Classic\", \"Romance\"],\n        ),\n        Book(\n            title=\"Wuthering Heights\",\n            author=authors[\"jane\"],\n            published_on=date(year=1600, month=4, day=4),\n            rating=4.0,\n            tags=[\"Classic\", \"Romance\"],\n        ),\n    ]\n\n    await Book.insert(books, life_span_seconds=3600)\n    all_books = await Book.select()\n    paginated_books = await Book.select(skip=2, limit=2)\n    paginated_books_with_few_fields = await Book.select(\n        columns=[\"author\", \"in_stock\"], skip=2, limit=2\n    )\n    print(\"All:\")\n    pp.pprint(all_books)\n    print(\"\\nPaginated:\")\n    pp.pprint(paginated_books)\n    print(\"\\nPaginated but with few fields:\")\n    pp.pprint(paginated_books_with_few_fields)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(run_async())\n</code></pre>"},{"location":"#run-it_1","title":"Run it","text":"<p>Run the example with:</p> <pre><code>$ python main.py\nAll:\n[   Book(title='Wuthering Heights', author=Author(name='Jane Austen', active_years=(1580, 1640)), rating=4.0, published_on=datetime.date(1600, 4, 4), tags=['Classic', 'Romance'], in_stock=True),\n    Book(title='Oliver Twist', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False),\n    Book(title='Jane Eyre', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=3.4, published_on=datetime.date(1225, 6, 4), tags=['Classic', 'Romance'], in_stock=False),\n    Book(title='Great Expectations', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=5.0, published_on=datetime.date(1220, 4, 4), tags=['Classic'], in_stock=True)]\n\nPaginated:\n[   Book(title='Jane Eyre', author=Author(name='Charles Dickens', active_years=(1220, 1280)), rating=3.4, published_on=datetime.date(1225, 6, 4), tags=['Classic', 'Romance'], in_stock=False),\n    Book(title='Wuthering Heights', author=Author(name='Jane Austen', active_years=(1580, 1640)), rating=4.0, published_on=datetime.date(1600, 4, 4), tags=['Classic', 'Romance'], in_stock=True)]\n\nPaginated but with few fields:\n[   {   'author': Author(name='Charles Dickens', active_years=(1220, 1280)),\n        'in_stock': False},\n    {   'author': Author(name='Jane Austen', active_years=(1580, 1640)),\n        'in_stock': True}]\n</code></pre>"},{"location":"change-log/","title":"Change Log","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"change-log/#unreleased","title":"[Unreleased]","text":""},{"location":"change-log/#050-2024-02-10","title":"[0.5.0] - 2024-02-10","text":""},{"location":"change-log/#added","title":"Added","text":""},{"location":"change-log/#changed","title":"Changed","text":"<ul> <li>Upgraded to pydantic v2.</li> </ul>"},{"location":"change-log/#fixed","title":"Fixed","text":"<ul> <li>Fixed orjson.JSONDecodeError when models have optional string fields</li> <li>Fixed ModuleNotFoundError: No module named 'mkdocstrings_handlers'</li> </ul>"},{"location":"change-log/#043-2022-12-29","title":"[0.4.3] - 2022-12-29","text":""},{"location":"change-log/#added_1","title":"Added","text":"<ul> <li>Added mkdocs documentation</li> </ul>"},{"location":"change-log/#changed_1","title":"Changed","text":"<ul> <li>Exposed <code>RedisConfig</code> via <code>pydantic_redis.config</code>, especially for documentation.</li> </ul>"},{"location":"change-log/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed docs building in CI</li> </ul>"},{"location":"change-log/#042-2022-12-29","title":"[0.4.2] - 2022-12-29","text":""},{"location":"change-log/#added_2","title":"Added","text":""},{"location":"change-log/#changed_2","title":"Changed","text":""},{"location":"change-log/#fixed_2","title":"Fixed","text":"<ul> <li>Fixed unexpected data error when selecting some columns for some records</li> </ul>"},{"location":"change-log/#041-2022-12-29","title":"[0.4.1] - 2022-12-29","text":""},{"location":"change-log/#added_3","title":"Added","text":""},{"location":"change-log/#changed_3","title":"Changed","text":""},{"location":"change-log/#fixed_3","title":"Fixed","text":""},{"location":"change-log/#040-2022-12-17","title":"[0.4.0] - 2022-12-17","text":""},{"location":"change-log/#added_4","title":"Added","text":"<ul> <li>Added pagination</li> </ul>"},{"location":"change-log/#changed_4","title":"Changed","text":"<ul> <li>Changed redis index to use sorted sets instead of ordinary sets</li> </ul>"},{"location":"change-log/#fixed_4","title":"Fixed","text":""},{"location":"change-log/#030-2022-12-15","title":"[0.3.0] - 2022-12-15","text":""},{"location":"change-log/#added_5","title":"Added","text":"<ul> <li>Added asyncio support, to be got from the <code>pydantic_redis.asyncio</code> module</li> </ul>"},{"location":"change-log/#changed_5","title":"Changed","text":"<ul> <li>Moved the synchronous version to the <code>pydantic_redis.syncio</code> module, but kept its contents exposed in pydantic_redis   for backward-compatibility</li> </ul>"},{"location":"change-log/#fixed_5","title":"Fixed","text":""},{"location":"change-log/#020-2022-12-15","title":"[0.2.0] - 2022-12-15","text":""},{"location":"change-log/#added_6","title":"Added","text":""},{"location":"change-log/#changed_6","title":"Changed","text":"<ul> <li>Changed the <code>NESTED_MODEL_LIST_FIELD_PREFIX</code> to <code>___</code> and <code>NESTED_MODEL_TUPLE_FIELD_PREFIX</code> to <code>____</code></li> <li>Changed all queries (selects) to use lua scripts</li> <li>Changed <code>Model.deserialize_partially</code> to receive data either as a dict or as a flattened list of key-values</li> </ul>"},{"location":"change-log/#fixed_6","title":"Fixed","text":""},{"location":"change-log/#018-2022-12-13","title":"[0.1.8] - 2022-12-13","text":""},{"location":"change-log/#added_7","title":"Added","text":"<ul> <li>Add support for model fields that are tuples of nested models </li> </ul>"},{"location":"change-log/#changed_7","title":"Changed","text":""},{"location":"change-log/#fixed_7","title":"Fixed","text":""},{"location":"change-log/#017-2022-12-12","title":"[0.1.7] - 2022-12-12","text":""},{"location":"change-log/#added_8","title":"Added","text":""},{"location":"change-log/#changed_8","title":"Changed","text":""},{"location":"change-log/#fixed_8","title":"Fixed","text":"<ul> <li>Fixed support for model properties that are Optional lists of nested models </li> <li>Fixed issue with field names being disfigured by <code>lstrip</code> when attempting to strip nested-mode-prefixes </li> </ul>"},{"location":"change-log/#016-2022-11-01","title":"[0.1.6] - 2022-11-01","text":""},{"location":"change-log/#added_9","title":"Added","text":"<ul> <li>Support for model properties that are lists of nested models </li> </ul>"},{"location":"change-log/#changed_9","title":"Changed","text":""},{"location":"change-log/#fixed_9","title":"Fixed","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pydantic_redis","title":"<code>pydantic_redis</code>","text":"<p>A simple declarative ORM for redis based on pydantic.</p> <p>Provides:</p> <ol> <li>A subclass-able <code>Model</code> class to create Object Relational Mapping to redis hashes</li> <li>A redis <code>Store</code> class to mutate and query <code>Model</code>'s registered in it</li> <li>A <code>RedisConfig</code> class to pass to the <code>Store</code> constructor to connect to a redis instance</li> <li>A synchronous <code>syncio</code> and an asynchronous <code>asyncio</code> interface to the above classes</li> <li>Parent-child relationships allowing for nesting models within models.</li> </ol>"},{"location":"reference/#pydantic_redis.syncio","title":"<code>pydantic_redis.syncio</code>","text":"<p>Synchronous API for pydantic-redis ORM.</p> <p>Typical usage example:</p> <pre><code># from pydantic_redis import Store, Model, RedisConfig\nfrom pydantic_redis.syncio import Store, Model, RedisConfig\n\nclass Book(Model):\n    _primary_key_field = 'title'\n    title: str\n\nif __name__ == '__main__':\n    store = Store(name=\"sample\", redis_config=RedisConfig())\n    store.register_model(Book)\n\n    Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    Book.update(\n        _id=\"Oliver Twist\", data={\"author\": \"Jane Austen\"}, life_span_seconds=3600\n    )\n    results = Book.select()\n    Book.delete(ids=[\"Oliver Twist\", \"Great Expectations\"])\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>AbstractModel</code></p> <p>The Base class for all Synchronous models.</p> <p>Inherit this class when creating a new model. The new model should have <code>_primary_key_field</code> defined. Any interaction with redis is done through <code>Model</code>'s.</p> Source code in <code>pydantic_redis/syncio/model.py</code> <pre><code>class Model(AbstractModel):\n    \"\"\"\n    The Base class for all Synchronous models.\n\n    Inherit this class when creating a new model.\n    The new model should have `_primary_key_field` defined.\n    Any interaction with redis is done through `Model`'s.\n    \"\"\"\n\n    _store: Store\n\n    @classmethod\n    def insert(\n        cls,\n        data: Union[List[AbstractModel], AbstractModel],\n        life_span_seconds: Optional[float] = None,\n    ):\n        \"\"\"Inserts a given record or list of records into the redis.\n\n        Can add a single record or multiple records into redis.\n        The records must be instances of this class. i.e. a `Book`\n        model can only insert `Book` instances.\n\n        Args:\n            data: a model instance or list of model instances to put\n                into the redis store\n            life_span_seconds: the time-to-live in seconds of the records\n                to be inserted. If not specified, it defaults to the `Store`'s\n                life_span_seconds.\n        \"\"\"\n        store = cls.get_store()\n\n        life_span = (\n            life_span_seconds\n            if life_span_seconds is not None\n            else store.life_span_in_seconds\n        )\n        with store.redis_store.pipeline(transaction=True) as pipeline:\n            data_list = []\n\n            if isinstance(data, list):\n                data_list = data\n            elif isinstance(data, AbstractModel):\n                data_list = [data]\n\n            for record in data_list:\n                insert_on_pipeline(\n                    model=cls,\n                    _id=None,\n                    pipeline=pipeline,\n                    record=record,\n                    life_span=life_span,\n                )\n\n            return pipeline.execute()\n\n    @classmethod\n    def update(\n        cls, _id: Any, data: Dict[str, Any], life_span_seconds: Optional[float] = None\n    ):\n        \"\"\"Updates the record whose primary key is `_id`.\n\n        Updates the record of this Model in redis whose primary key is equal to the `_id` provided.\n        The record is partially updated from the `data`.\n        If `life_span_seconds` is provided, it will also update the time-to-live of\n        the record.\n\n        Args:\n            _id: the primary key of record to be updated.\n            data: the new changes\n            life_span_seconds: the new time-to-live for the record\n        \"\"\"\n        store = cls.get_store()\n        life_span = (\n            life_span_seconds\n            if life_span_seconds is not None\n            else store.life_span_in_seconds\n        )\n        with store.redis_store.pipeline(transaction=True) as pipeline:\n            if isinstance(data, dict):\n                insert_on_pipeline(\n                    model=cls,\n                    _id=_id,\n                    pipeline=pipeline,\n                    record=data,\n                    life_span=life_span,\n                )\n\n            return pipeline.execute()\n\n    @classmethod\n    def delete(cls, ids: Union[Any, List[Any]]):\n        \"\"\"Removes a list of this Model's records from redis\n\n        Removes all the records for the current Model whose primary keys\n        have been included in the `ids` passed.\n\n        Args:\n            ids: list of primary keys of the records to remove\n        \"\"\"\n        store = cls.get_store()\n        with store.redis_store.pipeline() as pipeline:\n            delete_on_pipeline(model=cls, pipeline=pipeline, ids=ids)\n            return pipeline.execute()\n\n    @classmethod\n    def select(\n        cls,\n        columns: Optional[List[str]] = None,\n        ids: Optional[List[Any]] = None,\n        skip: int = 0,\n        limit: Optional[int] = None,\n        **kwargs,\n    ) -&gt; Union[\"Model\", Dict[str, Any]]:\n        \"\"\"Retrieves records of this Model from redis.\n\n        Retrieves the records for this Model from redis.\n\n        Args:\n            columns: the fields to return for each record\n            ids: the primary keys of the records to returns\n            skip: the number of records to skip. (default: 0)\n            limit: the maximum number of records to return\n\n        Returns:\n            By default, it returns all records that belong to current Model.\n\n            If `ids` are specified, it returns only records whose primary keys\n            have been listed in `ids`.\n\n            If `skip` and `limit` are specified WITHOUT `ids`, a slice of\n            all records are returned.\n\n            If `limit` and `ids` are specified, `limit` is ignored.\n\n            If `columns` are specified, a list of dictionaries containing only\n            the fields specified in `columns` is returned. Otherwise, instances\n            of the current Model are returned.\n        \"\"\"\n        if columns is None and ids is None:\n            response = select_all_fields_all_ids(model=cls, skip=skip, limit=limit)\n\n        elif columns is None and isinstance(ids, list):\n            response = select_all_fields_some_ids(model=cls, ids=ids)\n\n        elif isinstance(columns, list) and ids is None:\n            response = select_some_fields_all_ids(\n                model=cls, fields=columns, skip=skip, limit=limit\n            )\n\n        elif isinstance(columns, list) and isinstance(ids, list):\n            response = select_some_fields_some_ids(model=cls, fields=columns, ids=ids)\n\n        else:\n            raise ValueError(\n                f\"columns {columns}, ids: {ids} should be either None or lists\"\n            )\n\n        return parse_select_response(\n            model=cls, response=response, as_models=(columns is None)\n        )\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.Model.delete","title":"<code>delete(ids)</code>  <code>classmethod</code>","text":"<p>Removes a list of this Model's records from redis</p> <p>Removes all the records for the current Model whose primary keys have been included in the <code>ids</code> passed.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Union[Any, List[Any]]</code> <p>list of primary keys of the records to remove</p> required Source code in <code>pydantic_redis/syncio/model.py</code> <pre><code>@classmethod\ndef delete(cls, ids: Union[Any, List[Any]]):\n    \"\"\"Removes a list of this Model's records from redis\n\n    Removes all the records for the current Model whose primary keys\n    have been included in the `ids` passed.\n\n    Args:\n        ids: list of primary keys of the records to remove\n    \"\"\"\n    store = cls.get_store()\n    with store.redis_store.pipeline() as pipeline:\n        delete_on_pipeline(model=cls, pipeline=pipeline, ids=ids)\n        return pipeline.execute()\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.Model.insert","title":"<code>insert(data, life_span_seconds=None)</code>  <code>classmethod</code>","text":"<p>Inserts a given record or list of records into the redis.</p> <p>Can add a single record or multiple records into redis. The records must be instances of this class. i.e. a <code>Book</code> model can only insert <code>Book</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[List[AbstractModel], AbstractModel]</code> <p>a model instance or list of model instances to put into the redis store</p> required <code>life_span_seconds</code> <code>Optional[float]</code> <p>the time-to-live in seconds of the records to be inserted. If not specified, it defaults to the <code>Store</code>'s life_span_seconds.</p> <code>None</code> Source code in <code>pydantic_redis/syncio/model.py</code> <pre><code>@classmethod\ndef insert(\n    cls,\n    data: Union[List[AbstractModel], AbstractModel],\n    life_span_seconds: Optional[float] = None,\n):\n    \"\"\"Inserts a given record or list of records into the redis.\n\n    Can add a single record or multiple records into redis.\n    The records must be instances of this class. i.e. a `Book`\n    model can only insert `Book` instances.\n\n    Args:\n        data: a model instance or list of model instances to put\n            into the redis store\n        life_span_seconds: the time-to-live in seconds of the records\n            to be inserted. If not specified, it defaults to the `Store`'s\n            life_span_seconds.\n    \"\"\"\n    store = cls.get_store()\n\n    life_span = (\n        life_span_seconds\n        if life_span_seconds is not None\n        else store.life_span_in_seconds\n    )\n    with store.redis_store.pipeline(transaction=True) as pipeline:\n        data_list = []\n\n        if isinstance(data, list):\n            data_list = data\n        elif isinstance(data, AbstractModel):\n            data_list = [data]\n\n        for record in data_list:\n            insert_on_pipeline(\n                model=cls,\n                _id=None,\n                pipeline=pipeline,\n                record=record,\n                life_span=life_span,\n            )\n\n        return pipeline.execute()\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.Model.select","title":"<code>select(columns=None, ids=None, skip=0, limit=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Retrieves records of this Model from redis.</p> <p>Retrieves the records for this Model from redis.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[List[str]]</code> <p>the fields to return for each record</p> <code>None</code> <code>ids</code> <code>Optional[List[Any]]</code> <p>the primary keys of the records to returns</p> <code>None</code> <code>skip</code> <code>int</code> <p>the number of records to skip. (default: 0)</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>the maximum number of records to return</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Model, Dict[str, Any]]</code> <p>By default, it returns all records that belong to current Model.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>ids</code> are specified, it returns only records whose primary keys</p> <code>Union[Model, Dict[str, Any]]</code> <p>have been listed in <code>ids</code>.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>skip</code> and <code>limit</code> are specified WITHOUT <code>ids</code>, a slice of</p> <code>Union[Model, Dict[str, Any]]</code> <p>all records are returned.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>limit</code> and <code>ids</code> are specified, <code>limit</code> is ignored.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>columns</code> are specified, a list of dictionaries containing only</p> <code>Union[Model, Dict[str, Any]]</code> <p>the fields specified in <code>columns</code> is returned. Otherwise, instances</p> <code>Union[Model, Dict[str, Any]]</code> <p>of the current Model are returned.</p> Source code in <code>pydantic_redis/syncio/model.py</code> <pre><code>@classmethod\ndef select(\n    cls,\n    columns: Optional[List[str]] = None,\n    ids: Optional[List[Any]] = None,\n    skip: int = 0,\n    limit: Optional[int] = None,\n    **kwargs,\n) -&gt; Union[\"Model\", Dict[str, Any]]:\n    \"\"\"Retrieves records of this Model from redis.\n\n    Retrieves the records for this Model from redis.\n\n    Args:\n        columns: the fields to return for each record\n        ids: the primary keys of the records to returns\n        skip: the number of records to skip. (default: 0)\n        limit: the maximum number of records to return\n\n    Returns:\n        By default, it returns all records that belong to current Model.\n\n        If `ids` are specified, it returns only records whose primary keys\n        have been listed in `ids`.\n\n        If `skip` and `limit` are specified WITHOUT `ids`, a slice of\n        all records are returned.\n\n        If `limit` and `ids` are specified, `limit` is ignored.\n\n        If `columns` are specified, a list of dictionaries containing only\n        the fields specified in `columns` is returned. Otherwise, instances\n        of the current Model are returned.\n    \"\"\"\n    if columns is None and ids is None:\n        response = select_all_fields_all_ids(model=cls, skip=skip, limit=limit)\n\n    elif columns is None and isinstance(ids, list):\n        response = select_all_fields_some_ids(model=cls, ids=ids)\n\n    elif isinstance(columns, list) and ids is None:\n        response = select_some_fields_all_ids(\n            model=cls, fields=columns, skip=skip, limit=limit\n        )\n\n    elif isinstance(columns, list) and isinstance(ids, list):\n        response = select_some_fields_some_ids(model=cls, fields=columns, ids=ids)\n\n    else:\n        raise ValueError(\n            f\"columns {columns}, ids: {ids} should be either None or lists\"\n        )\n\n    return parse_select_response(\n        model=cls, response=response, as_models=(columns is None)\n    )\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.Model.update","title":"<code>update(_id, data, life_span_seconds=None)</code>  <code>classmethod</code>","text":"<p>Updates the record whose primary key is <code>_id</code>.</p> <p>Updates the record of this Model in redis whose primary key is equal to the <code>_id</code> provided. The record is partially updated from the <code>data</code>. If <code>life_span_seconds</code> is provided, it will also update the time-to-live of the record.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>Any</code> <p>the primary key of record to be updated.</p> required <code>data</code> <code>Dict[str, Any]</code> <p>the new changes</p> required <code>life_span_seconds</code> <code>Optional[float]</code> <p>the new time-to-live for the record</p> <code>None</code> Source code in <code>pydantic_redis/syncio/model.py</code> <pre><code>@classmethod\ndef update(\n    cls, _id: Any, data: Dict[str, Any], life_span_seconds: Optional[float] = None\n):\n    \"\"\"Updates the record whose primary key is `_id`.\n\n    Updates the record of this Model in redis whose primary key is equal to the `_id` provided.\n    The record is partially updated from the `data`.\n    If `life_span_seconds` is provided, it will also update the time-to-live of\n    the record.\n\n    Args:\n        _id: the primary key of record to be updated.\n        data: the new changes\n        life_span_seconds: the new time-to-live for the record\n    \"\"\"\n    store = cls.get_store()\n    life_span = (\n        life_span_seconds\n        if life_span_seconds is not None\n        else store.life_span_in_seconds\n    )\n    with store.redis_store.pipeline(transaction=True) as pipeline:\n        if isinstance(data, dict):\n            insert_on_pipeline(\n                model=cls,\n                _id=_id,\n                pipeline=pipeline,\n                record=data,\n                life_span=life_span,\n            )\n\n        return pipeline.execute()\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.RedisConfig","title":"<code>RedisConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for connecting to redis database.</p> <p>Inorder to connect to a redis database, there are a number of configurations that are needed including the server's host address and port. <code>RedisConfig</code> computes a redis-url similar to <code>redis://:password@host:self.port/db</code></p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>the host address where the redis server is found (default: 'localhost').</p> <code>port</code> <code>int</code> <p>the port on which the redis server is running (default: 6379).</p> <code>db</code> <code>int</code> <p>the redis database identifier (default: 0).</p> <code>password</code> <code>Optional[int]</code> <p>the password for connecting to the redis server (default: None).</p> <code>ssl</code> <code>bool</code> <p>whether the connection to the redis server is to be via TLS (default: False)</p> <code>encoding</code> <code>Optional[str]</code> <p>(Optional[str]): the string encoding used with the redis database (default: utf-8)</p> Source code in <code>pydantic_redis/config.py</code> <pre><code>class RedisConfig(BaseModel):\n    \"\"\"Configuration for connecting to redis database.\n\n    Inorder to connect to a redis database, there are a number of\n    configurations that are needed including the server's host address\n    and port. `RedisConfig` computes a redis-url similar to\n    `redis://:password@host:self.port/db`\n\n    Attributes:\n        host (str): the host address where the redis server is found (default: 'localhost').\n        port (int): the port on which the redis server is running (default: 6379).\n        db (int): the redis database identifier (default: 0).\n        password (Optional[int]): the password for connecting to the\n            redis server (default: None).\n        ssl (bool): whether the connection to the redis server is to be via TLS (default: False)\n        encoding: (Optional[str]): the string encoding used with the redis database\n            (default: utf-8)\n    \"\"\"\n\n    model_config = ConfigDict(from_attributes=True)\n\n    host: str = \"localhost\"\n    port: int = 6379\n    db: int = 0\n    password: Optional[str] = None\n    ssl: bool = False\n    encoding: Optional[str] = \"utf-8\"\n\n    @property\n    def redis_url(self) -&gt; str:\n        \"\"\"a redis URL of form `redis://:password@host:port/db`. (`rediss://..` if TLS).\"\"\"\n        proto = \"rediss\" if self.ssl else \"redis\"\n        if self.password is None:\n            return f\"{proto}://{self.host}:{self.port}/{self.db}\"\n        return f\"{proto}://:{self.password}@{self.host}:{self.port}/{self.db}\"\n</code></pre>"},{"location":"reference/#pydantic_redis.syncio.RedisConfig.redis_url","title":"<code>redis_url: str</code>  <code>property</code>","text":"<p>a redis URL of form <code>redis://:password@host:port/db</code>. (<code>rediss://..</code> if TLS).</p>"},{"location":"reference/#pydantic_redis.syncio.Store","title":"<code>Store</code>","text":"<p>               Bases: <code>AbstractStore</code></p> <p>Manages a collection of Model's, connecting them to a redis database</p> <p>A Model can only interact with a redis database when it is registered with a <code>Store</code> that is connected to that database.</p> <p>Attributes:</p> Name Type Description <code>models</code> <code>Dict[str, Type[Model]]</code> <p>a mapping of registered <code>Model</code>'s, with the keys being the Model name</p> <code>name</code> <code>str</code> <p>the name of this Store</p> <code>redis_config</code> <code>RedisConfig</code> <p>the configuration for connecting to a redis database</p> <code>life_span_in_seconds</code> <code>Optional[int]</code> <p>the default time-to-live for the records inserted in this store (default: None)</p> Source code in <code>pydantic_redis/syncio/store.py</code> <pre><code>class Store(AbstractStore):\n    \"\"\"Manages a collection of Model's, connecting them to a redis database\n\n    A Model can only interact with a redis database when it is registered\n    with a `Store` that is connected to that database.\n\n    Attributes:\n        models (Dict[str, Type[pydantic_redis.syncio.Model]]): a mapping of registered `Model`'s, with the keys being the\n            Model name\n        name (str): the name of this Store\n        redis_config (pydantic_redis.syncio.RedisConfig): the configuration for connecting to a redis database\n        life_span_in_seconds (Optional[int]): the default time-to-live for the records inserted in this store\n            (default: None)\n    \"\"\"\n\n    models: Dict[str, Type[\"Model\"]] = {}\n\n    def _connect_to_redis(self) -&gt; redis.Redis:\n        \"\"\"Connects the store to redis.\n\n        See base class.\n        \"\"\"\n        return redis.from_url(\n            self.redis_config.redis_url,\n            encoding=self.redis_config.encoding,\n            decode_responses=True,\n        )\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio","title":"<code>pydantic_redis.asyncio</code>","text":"<p>Asynchronous API for pydantic-redis ORM.</p> <p>Typical usage example:</p> <pre><code>import asyncio\nfrom pydantic_redis.asyncio import Store, Model, RedisConfig\n\nclass Book(Model):\n    _primary_key_field = 'title'\n    title: str\n\nasync def main():\n    store = Store(name=\"sample\", redis_config=RedisConfig())\n    store.register_model(Book)\n\n    await Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    await Book.update(\n        _id=\"Oliver Twist\", data={\"author\": \"Jane Austen\"}, life_span_seconds=3600\n    )\n    results = await Book.select()\n    await Book.delete(ids=[\"Oliver Twist\", \"Great Expectations\"])\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>AbstractModel</code></p> <p>The Base class for all Asynchronous models.</p> <p>Inherit this class when creating a new model. The new model should have <code>_primary_key_field</code> defined. Any interaction with redis is done through <code>Model</code>'s.</p> Source code in <code>pydantic_redis/asyncio/model.py</code> <pre><code>class Model(AbstractModel):\n    \"\"\"The Base class for all Asynchronous models.\n\n    Inherit this class when creating a new model.\n    The new model should have `_primary_key_field` defined.\n    Any interaction with redis is done through `Model`'s.\n    \"\"\"\n\n    _store: Store\n\n    @classmethod\n    async def insert(\n        cls,\n        data: Union[List[AbstractModel], AbstractModel],\n        life_span_seconds: Optional[float] = None,\n    ):\n        \"\"\"Inserts a given record or list of records into the redis.\n\n        Can add a single record or multiple records into redis.\n        The records must be instances of this class. i.e. a `Book`\n        model can only insert `Book` instances.\n\n        Args:\n            data: a model instance or list of model instances to put\n                into the redis store\n            life_span_seconds: the time-to-live in seconds of the records\n                to be inserted. If not specified, it defaults to the `Store`'s\n                life_span_seconds.\n        \"\"\"\n        store = cls.get_store()\n        life_span = (\n            life_span_seconds\n            if life_span_seconds is not None\n            else store.life_span_in_seconds\n        )\n\n        async with store.redis_store.pipeline(transaction=True) as pipeline:\n            data_list = []\n\n            if isinstance(data, list):\n                data_list = data\n            elif isinstance(data, AbstractModel):\n                data_list = [data]\n\n            for record in data_list:\n                insert_on_pipeline(\n                    model=cls,\n                    _id=None,\n                    pipeline=pipeline,\n                    record=record,\n                    life_span=life_span,\n                )\n\n            return await pipeline.execute()\n\n    @classmethod\n    async def update(\n        cls, _id: Any, data: Dict[str, Any], life_span_seconds: Optional[float] = None\n    ):\n        \"\"\"Updates the record whose primary key is `_id`.\n\n        Updates the record of this Model in redis whose primary key is equal to the `_id` provided.\n        The record is partially updated from the `data`.\n        If `life_span_seconds` is provided, it will also update the time-to-live of\n        the record.\n\n        Args:\n            _id: the primary key of record to be updated.\n            data: the new changes\n            life_span_seconds: the new time-to-live for the record\n        \"\"\"\n        store = cls.get_store()\n        life_span = (\n            life_span_seconds\n            if life_span_seconds is not None\n            else store.life_span_in_seconds\n        )\n        async with store.redis_store.pipeline(transaction=True) as pipeline:\n            if isinstance(data, dict):\n                insert_on_pipeline(\n                    model=cls,\n                    _id=_id,\n                    pipeline=pipeline,\n                    record=data,\n                    life_span=life_span,\n                )\n\n            return await pipeline.execute()\n\n    @classmethod\n    async def delete(cls, ids: Union[Any, List[Any]]):\n        \"\"\"Removes a list of this Model's records from redis\n\n        Removes all the records for the current Model whose primary keys\n        have been included in the `ids` passed.\n\n        Args:\n            ids: list of primary keys of the records to remove\n        \"\"\"\n        store = cls.get_store()\n\n        async with store.redis_store.pipeline() as pipeline:\n            delete_on_pipeline(model=cls, pipeline=pipeline, ids=ids)\n            return await pipeline.execute()\n\n    @classmethod\n    async def select(\n        cls,\n        columns: Optional[List[str]] = None,\n        ids: Optional[List[Any]] = None,\n        skip: int = 0,\n        limit: Optional[int] = None,\n        **kwargs,\n    ) -&gt; Union[\"Model\", Dict[str, Any]]:\n        \"\"\"Retrieves records of this Model from redis.\n\n        Retrieves the records for this Model from redis.\n\n        Args:\n            columns: the fields to return for each record\n            ids: the primary keys of the records to returns\n            skip: the number of records to skip. (default: 0)\n            limit: the maximum number of records to return\n\n        Returns:\n            By default, it returns all records that belong to current Model.\n\n            If `ids` are specified, it returns only records whose primary keys\n            have been listed in `ids`.\n\n            If `skip` and `limit` are specified WITHOUT `ids`, a slice of\n            all records are returned.\n\n            If `limit` and `ids` are specified, `limit` is ignored.\n\n            If `columns` are specified, a list of dictionaries containing only\n            the fields specified in `columns` is returned. Otherwise, instances\n            of the current Model are returned.\n        \"\"\"\n        if columns is None and ids is None:\n            response = await select_all_fields_all_ids(\n                model=cls, skip=skip, limit=limit\n            )\n\n        elif columns is None and isinstance(ids, list):\n            response = await select_all_fields_some_ids(model=cls, ids=ids)\n\n        elif isinstance(columns, list) and ids is None:\n            response = await select_some_fields_all_ids(\n                model=cls, fields=columns, skip=skip, limit=limit\n            )\n\n        elif isinstance(columns, list) and isinstance(ids, list):\n            response = await select_some_fields_some_ids(\n                model=cls, fields=columns, ids=ids\n            )\n\n        else:\n            raise ValueError(\n                f\"columns {columns}, ids: {ids} should be either None or lists\"\n            )\n\n        return parse_select_response(\n            model=cls, response=response, as_models=(columns is None)\n        )\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.Model.delete","title":"<code>delete(ids)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Removes a list of this Model's records from redis</p> <p>Removes all the records for the current Model whose primary keys have been included in the <code>ids</code> passed.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>Union[Any, List[Any]]</code> <p>list of primary keys of the records to remove</p> required Source code in <code>pydantic_redis/asyncio/model.py</code> <pre><code>@classmethod\nasync def delete(cls, ids: Union[Any, List[Any]]):\n    \"\"\"Removes a list of this Model's records from redis\n\n    Removes all the records for the current Model whose primary keys\n    have been included in the `ids` passed.\n\n    Args:\n        ids: list of primary keys of the records to remove\n    \"\"\"\n    store = cls.get_store()\n\n    async with store.redis_store.pipeline() as pipeline:\n        delete_on_pipeline(model=cls, pipeline=pipeline, ids=ids)\n        return await pipeline.execute()\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.Model.insert","title":"<code>insert(data, life_span_seconds=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Inserts a given record or list of records into the redis.</p> <p>Can add a single record or multiple records into redis. The records must be instances of this class. i.e. a <code>Book</code> model can only insert <code>Book</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[List[AbstractModel], AbstractModel]</code> <p>a model instance or list of model instances to put into the redis store</p> required <code>life_span_seconds</code> <code>Optional[float]</code> <p>the time-to-live in seconds of the records to be inserted. If not specified, it defaults to the <code>Store</code>'s life_span_seconds.</p> <code>None</code> Source code in <code>pydantic_redis/asyncio/model.py</code> <pre><code>@classmethod\nasync def insert(\n    cls,\n    data: Union[List[AbstractModel], AbstractModel],\n    life_span_seconds: Optional[float] = None,\n):\n    \"\"\"Inserts a given record or list of records into the redis.\n\n    Can add a single record or multiple records into redis.\n    The records must be instances of this class. i.e. a `Book`\n    model can only insert `Book` instances.\n\n    Args:\n        data: a model instance or list of model instances to put\n            into the redis store\n        life_span_seconds: the time-to-live in seconds of the records\n            to be inserted. If not specified, it defaults to the `Store`'s\n            life_span_seconds.\n    \"\"\"\n    store = cls.get_store()\n    life_span = (\n        life_span_seconds\n        if life_span_seconds is not None\n        else store.life_span_in_seconds\n    )\n\n    async with store.redis_store.pipeline(transaction=True) as pipeline:\n        data_list = []\n\n        if isinstance(data, list):\n            data_list = data\n        elif isinstance(data, AbstractModel):\n            data_list = [data]\n\n        for record in data_list:\n            insert_on_pipeline(\n                model=cls,\n                _id=None,\n                pipeline=pipeline,\n                record=record,\n                life_span=life_span,\n            )\n\n        return await pipeline.execute()\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.Model.select","title":"<code>select(columns=None, ids=None, skip=0, limit=None, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Retrieves records of this Model from redis.</p> <p>Retrieves the records for this Model from redis.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[List[str]]</code> <p>the fields to return for each record</p> <code>None</code> <code>ids</code> <code>Optional[List[Any]]</code> <p>the primary keys of the records to returns</p> <code>None</code> <code>skip</code> <code>int</code> <p>the number of records to skip. (default: 0)</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>the maximum number of records to return</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Model, Dict[str, Any]]</code> <p>By default, it returns all records that belong to current Model.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>ids</code> are specified, it returns only records whose primary keys</p> <code>Union[Model, Dict[str, Any]]</code> <p>have been listed in <code>ids</code>.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>skip</code> and <code>limit</code> are specified WITHOUT <code>ids</code>, a slice of</p> <code>Union[Model, Dict[str, Any]]</code> <p>all records are returned.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>limit</code> and <code>ids</code> are specified, <code>limit</code> is ignored.</p> <code>Union[Model, Dict[str, Any]]</code> <p>If <code>columns</code> are specified, a list of dictionaries containing only</p> <code>Union[Model, Dict[str, Any]]</code> <p>the fields specified in <code>columns</code> is returned. Otherwise, instances</p> <code>Union[Model, Dict[str, Any]]</code> <p>of the current Model are returned.</p> Source code in <code>pydantic_redis/asyncio/model.py</code> <pre><code>@classmethod\nasync def select(\n    cls,\n    columns: Optional[List[str]] = None,\n    ids: Optional[List[Any]] = None,\n    skip: int = 0,\n    limit: Optional[int] = None,\n    **kwargs,\n) -&gt; Union[\"Model\", Dict[str, Any]]:\n    \"\"\"Retrieves records of this Model from redis.\n\n    Retrieves the records for this Model from redis.\n\n    Args:\n        columns: the fields to return for each record\n        ids: the primary keys of the records to returns\n        skip: the number of records to skip. (default: 0)\n        limit: the maximum number of records to return\n\n    Returns:\n        By default, it returns all records that belong to current Model.\n\n        If `ids` are specified, it returns only records whose primary keys\n        have been listed in `ids`.\n\n        If `skip` and `limit` are specified WITHOUT `ids`, a slice of\n        all records are returned.\n\n        If `limit` and `ids` are specified, `limit` is ignored.\n\n        If `columns` are specified, a list of dictionaries containing only\n        the fields specified in `columns` is returned. Otherwise, instances\n        of the current Model are returned.\n    \"\"\"\n    if columns is None and ids is None:\n        response = await select_all_fields_all_ids(\n            model=cls, skip=skip, limit=limit\n        )\n\n    elif columns is None and isinstance(ids, list):\n        response = await select_all_fields_some_ids(model=cls, ids=ids)\n\n    elif isinstance(columns, list) and ids is None:\n        response = await select_some_fields_all_ids(\n            model=cls, fields=columns, skip=skip, limit=limit\n        )\n\n    elif isinstance(columns, list) and isinstance(ids, list):\n        response = await select_some_fields_some_ids(\n            model=cls, fields=columns, ids=ids\n        )\n\n    else:\n        raise ValueError(\n            f\"columns {columns}, ids: {ids} should be either None or lists\"\n        )\n\n    return parse_select_response(\n        model=cls, response=response, as_models=(columns is None)\n    )\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.Model.update","title":"<code>update(_id, data, life_span_seconds=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Updates the record whose primary key is <code>_id</code>.</p> <p>Updates the record of this Model in redis whose primary key is equal to the <code>_id</code> provided. The record is partially updated from the <code>data</code>. If <code>life_span_seconds</code> is provided, it will also update the time-to-live of the record.</p> <p>Parameters:</p> Name Type Description Default <code>_id</code> <code>Any</code> <p>the primary key of record to be updated.</p> required <code>data</code> <code>Dict[str, Any]</code> <p>the new changes</p> required <code>life_span_seconds</code> <code>Optional[float]</code> <p>the new time-to-live for the record</p> <code>None</code> Source code in <code>pydantic_redis/asyncio/model.py</code> <pre><code>@classmethod\nasync def update(\n    cls, _id: Any, data: Dict[str, Any], life_span_seconds: Optional[float] = None\n):\n    \"\"\"Updates the record whose primary key is `_id`.\n\n    Updates the record of this Model in redis whose primary key is equal to the `_id` provided.\n    The record is partially updated from the `data`.\n    If `life_span_seconds` is provided, it will also update the time-to-live of\n    the record.\n\n    Args:\n        _id: the primary key of record to be updated.\n        data: the new changes\n        life_span_seconds: the new time-to-live for the record\n    \"\"\"\n    store = cls.get_store()\n    life_span = (\n        life_span_seconds\n        if life_span_seconds is not None\n        else store.life_span_in_seconds\n    )\n    async with store.redis_store.pipeline(transaction=True) as pipeline:\n        if isinstance(data, dict):\n            insert_on_pipeline(\n                model=cls,\n                _id=_id,\n                pipeline=pipeline,\n                record=data,\n                life_span=life_span,\n            )\n\n        return await pipeline.execute()\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.RedisConfig","title":"<code>RedisConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for connecting to redis database.</p> <p>Inorder to connect to a redis database, there are a number of configurations that are needed including the server's host address and port. <code>RedisConfig</code> computes a redis-url similar to <code>redis://:password@host:self.port/db</code></p> <p>Attributes:</p> Name Type Description <code>host</code> <code>str</code> <p>the host address where the redis server is found (default: 'localhost').</p> <code>port</code> <code>int</code> <p>the port on which the redis server is running (default: 6379).</p> <code>db</code> <code>int</code> <p>the redis database identifier (default: 0).</p> <code>password</code> <code>Optional[int]</code> <p>the password for connecting to the redis server (default: None).</p> <code>ssl</code> <code>bool</code> <p>whether the connection to the redis server is to be via TLS (default: False)</p> <code>encoding</code> <code>Optional[str]</code> <p>(Optional[str]): the string encoding used with the redis database (default: utf-8)</p> Source code in <code>pydantic_redis/config.py</code> <pre><code>class RedisConfig(BaseModel):\n    \"\"\"Configuration for connecting to redis database.\n\n    Inorder to connect to a redis database, there are a number of\n    configurations that are needed including the server's host address\n    and port. `RedisConfig` computes a redis-url similar to\n    `redis://:password@host:self.port/db`\n\n    Attributes:\n        host (str): the host address where the redis server is found (default: 'localhost').\n        port (int): the port on which the redis server is running (default: 6379).\n        db (int): the redis database identifier (default: 0).\n        password (Optional[int]): the password for connecting to the\n            redis server (default: None).\n        ssl (bool): whether the connection to the redis server is to be via TLS (default: False)\n        encoding: (Optional[str]): the string encoding used with the redis database\n            (default: utf-8)\n    \"\"\"\n\n    model_config = ConfigDict(from_attributes=True)\n\n    host: str = \"localhost\"\n    port: int = 6379\n    db: int = 0\n    password: Optional[str] = None\n    ssl: bool = False\n    encoding: Optional[str] = \"utf-8\"\n\n    @property\n    def redis_url(self) -&gt; str:\n        \"\"\"a redis URL of form `redis://:password@host:port/db`. (`rediss://..` if TLS).\"\"\"\n        proto = \"rediss\" if self.ssl else \"redis\"\n        if self.password is None:\n            return f\"{proto}://{self.host}:{self.port}/{self.db}\"\n        return f\"{proto}://:{self.password}@{self.host}:{self.port}/{self.db}\"\n</code></pre>"},{"location":"reference/#pydantic_redis.asyncio.RedisConfig.redis_url","title":"<code>redis_url: str</code>  <code>property</code>","text":"<p>a redis URL of form <code>redis://:password@host:port/db</code>. (<code>rediss://..</code> if TLS).</p>"},{"location":"reference/#pydantic_redis.asyncio.Store","title":"<code>Store</code>","text":"<p>               Bases: <code>AbstractStore</code></p> <p>Manages a collection of Model's, connecting them to a redis database</p> <p>A Model can only interact with a redis database when it is registered with a <code>Store</code> that is connected to that database.</p> <p>Attributes:</p> Name Type Description <code>models</code> <code>Dict[str, Type[Model]]</code> <p>a mapping of registered <code>Model</code>'s, with the keys being the Model name</p> <code>name</code> <code>str</code> <p>the name of this Store</p> <code>redis_config</code> <code>RedisConfig</code> <p>the configuration for connecting to a redis database</p> <code>life_span_in_seconds</code> <code>Optional[int]</code> <p>the default time-to-live for the records inserted in this store (default: None)</p> Source code in <code>pydantic_redis/asyncio/store.py</code> <pre><code>class Store(AbstractStore):\n    \"\"\"Manages a collection of Model's, connecting them to a redis database\n\n    A Model can only interact with a redis database when it is registered\n    with a `Store` that is connected to that database.\n\n    Attributes:\n        models (Dict[str, Type[pydantic_redis.syncio.Model]]): a mapping of registered `Model`'s, with the keys being the\n            Model name\n        name (str): the name of this Store\n        redis_config (pydantic_redis.syncio.RedisConfig): the configuration for connecting to a redis database\n        life_span_in_seconds (Optional[int]): the default time-to-live for the records inserted in this store\n            (default: None)\n    \"\"\"\n\n    models: Dict[str, Type[\"Model\"]] = {}\n\n    def _connect_to_redis(self) -&gt; redis.Redis:\n        \"\"\"Connects the store to redis.\n\n        See the base class.\n        \"\"\"\n        return redis.from_url(\n            self.redis_config.redis_url,\n            encoding=self.redis_config.encoding,\n            decode_responses=True,\n        )\n</code></pre>"},{"location":"explanation/why-use-orms/","title":"Why Use ORMs","text":"<p>An object-relational-mapping (ORM) makes writing business logic intuitive  because the data representation is closer to what the real-life situation is.  It helps decouple the way such data is programmed from the way such data is  actually persisted in any of the data persistence technologies we have,  typically a database.</p> <p>Take the example of a book. In code, one will represent a book as an object with a number of properties such as \"title\", \"edition\", \"author\" etc.</p> <pre><code>class Book(Model):\n  title: str\n  edition: int\n  author: Author\n</code></pre> <p>However, in the underlying data store, the same book could be saved as say, a row in a table for a relational database like PostgreSQL, or as a document in a document-based NoSQL databases like MongoDB  or as a hashmap in redis. Of these, the document-based NoSQL databases are the closest to the definition in code.</p> <p>For MongoDB, the same book might be represented as the object below:</p> <pre><code>{\n  \"id\": \"some-random-string\",\n  \"title\": \"the title of the book\",\n  \"edition\": 2,\n  \"author\": {\n    \"name\": \"Charles Payne\",\n    \"yearsActive\": [\n      1992,\n      2008\n    ]\n  }\n}\n</code></pre> <p>As you can see, it is still quite different.</p> <p>However, for redis, the representation is even going to be further off. It will most likely be saved as hashmap, with a given key.  The properties of book will be 'fields' for that hashmap.</p> <p>In order to interact with the book representation in the redis server,  one has to write commands like:</p> <pre><code># to save the book in the data store\nHSET \"some key\" \"title\" \"the title of the book\" \"edition\" 2 \"author\" \"{\\\"name\\\":\\\"Charles Payne\\\",\\\"yearsActive\\\":[1992,2008]}\"\n# to retrieve the entire book\nHGETALL \"some key\"\n# to retrieve just a few details of the book\nHMGET \"some key\" \"title\" \"edition\"\n# to update the book - see the confusion? are you saving a new book or updating one?\nHSET \"some key\" \"edition\" 2\n# to delete the book\nDEL \"some key\"\n</code></pre> <p>The above is so unrelated to the business logic that most of us  will take a number of minutes or hours trying to understand what  kind of data is even being saved. </p> <p>Is it a book or some random stuff?</p> <p>Now consider something like this:</p> <pre><code>book = Book(title=\"some title\", edition=2, author=Author(name=\"Charles Payne\", years_active=(1992, 2008)))\nstore = Store(url=\"redis://localhost:6379/0\", pool_size=5, default_ttl=3000, timeout=1)\nstore.register_model(Book)\n\nBook.insert(data=book)\nresponse = Book.select(ids=[\"some title\"])\nBook.update(_id=\"some title\", data={\"edition\": 1})\nBook.delete(ids=[\"some title\", \"another title\"])\n</code></pre> <p>Beautiful, isn't it?</p>"},{"location":"tutorials/intro/","title":"Intro","text":"<p>This tutorial shows you how to use pydantic-redis step by step.</p> <p>There are two tutorials: Synchronous API and Asynchronous API.</p> <p>In either tutorials, each child section gradually builds on the previous one. These child sections are separate topics so that one can go directly to a specific topic, just like a reference.</p>"},{"location":"tutorials/intro/#synchronous-api","title":"Synchronous API","text":"<p>In case you are looking to use pydantic-redis without async/await, you can read the Synchronous API version of this tutorial.</p> <p>Info</p> <p>This is the default API for pydantic-redis.</p>"},{"location":"tutorials/intro/#asynchronous-api","title":"Asynchronous API","text":"<p>In case you are looking to use pydantic-redis with async/await, e.g. in FastAPI or asyncio , you can read the Asynchronous API version of this tutorial.</p>"},{"location":"tutorials/intro/#install-python","title":"Install Python","text":"<p>Pydantic-redis requires python 3.8 and above. The latest stable python version is the recommended version.</p> <p>You can install python from the official python downloads site.</p>"},{"location":"tutorials/intro/#install-redis","title":"Install Redis","text":"<p>In order to use pydantic-redis, you need a redis server instance running. You can install a local instance via the official redis stack instructions.</p> <p>Info</p> <p>You may also need a visual client to view the data in redis. The recommended app to use is RedisInsight.</p>"},{"location":"tutorials/intro/#run-the-code","title":"Run the Code","text":"<p>All the code blocks can be copied and used directly.</p> <p>To run any of the examples, copy the code to a file <code>main.py</code>, and run the command below in your terminal:</p> <pre><code>$ python main.py\n</code></pre>"},{"location":"tutorials/intro/#install-pydantic-redis","title":"Install Pydantic-redis","text":"<p>First install pydantic-redis</p> <pre><code>$ pip install pydantic-redis\n\n---&gt; 100%\n</code></pre>"},{"location":"tutorials/asynchronous/delete/","title":"Delete","text":"<p>Pydantic-redis can be used to delete model instances from redis.</p>"},{"location":"tutorials/asynchronous/delete/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n    pre_delete_response = await Book.select()\n\n    await Book.delete(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n    post_delete_response = await Book.select()\n\n    print(\"pre-delete:\")\n    pp.pprint(pre_delete_response)\n\n    print(\"\\npost-delete:\")\n    pp.pprint(post_delete_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/delete/#delete-records","title":"Delete Records","text":"<p>To delete many records from redis, pass a list of primary keys (<code>ids</code>) of the records to the model's <code>delete</code> method.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n    pre_delete_response = await Book.select()\n\n    await Book.delete(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n    post_delete_response = await Book.select()\n\n    print(\"pre-delete:\")\n    pp.pprint(pre_delete_response)\n\n    print(\"\\npost-delete:\")\n    pp.pprint(post_delete_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/delete/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\npre-delete:\n[   Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Utah Blaine', author=\"Louis L'Amour\"),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\npost-delete:\n[   Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Utah Blaine', author=\"Louis L'Amour\")]\n</code></pre>"},{"location":"tutorials/asynchronous/insert/","title":"Insert","text":"<p>Pydantic-redis can be used to insert new model instances into redis.</p>"},{"location":"tutorials/asynchronous/insert/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    await Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = await Book.select()\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/insert/#insert-one-record","title":"Insert One Record","text":"<p>To add a single record to the redis instance, pass that model's instance as first argument to the model's <code>insert</code>  method</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    await Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = await Book.select()\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/insert/#insert-one-record-with-ttl","title":"Insert One Record With TTL","text":"<p>To make the record added to redis temporary, add a <code>life_span_seconds</code> (Time To Live i.e. TTL) key-word argument  when calling the model's <code>insert</code> method.</p> <p>Info</p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used.</p> <p>The <code>life_span_in_seconds</code> in both cases is <code>None</code> by default. This means records never expire by default.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    await Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = await Book.select()\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/insert/#insert-many-records","title":"Insert Many Records","text":"<p>To add many records to the redis instance, pass a list of that model's instances as first argument to the model's <code>insert</code> method.</p> <p>Info</p> <p>Adding many records at once is more performant than adding one record at a time repeatedly because less network requests are made in the former.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    await Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = await Book.select()\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/insert/#insert-many-records-with-ttl","title":"Insert Many Records With TTL","text":"<p>To add temporary records to redis, add a <code>life_span_seconds</code> (Time To Live i.e. TTL) argument  when calling the model's <code>insert</code> method.</p> <p>Info</p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used.</p> <p>The <code>life_span_in_seconds</code> in both cases is <code>None</code> by default. This means records never expire by default.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    await Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = await Book.select()\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/insert/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\n[   Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Great Expectations', author='Charles Dickens'),\n    Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/","title":"Lists of Nested Models","text":"<p>Sometimes, one might need to have models (schemas) that have lists of other models (schemas).</p> <p>An example is a <code>Folder</code> model that can have child <code>Folder</code>'s and <code>File</code>'s.</p> <p>This can easily be pulled off with pydantic-redis.</p>"},{"location":"tutorials/asynchronous/list-of-nested-models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import <code>pydantic-redis.asyncio</code>'s <code>Model</code></p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#create-the-child-model","title":"Create the Child Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#set-the-_primary_key_field-of-the-child-model","title":"Set the <code>_primary_key_field</code> of the Child Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two <code>File</code>'s with the same <code>path</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#create-the-parent-model","title":"Create the Parent Model","text":"<p>Next, declare another model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes, as before.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#add-the-nested-model-list-to-the-parent-model","title":"Add the Nested Model List to the Parent Model","text":"<p>Annotate the field that is to hold the child model list with the List of child class. </p> <p>Example</p> <p>In this case, the field <code>files</code> is annotated with <code>List[File]</code>.</p> <p>And the field <code>folders</code> is annotated with <code>\"Folder\"</code> class i.e. itself.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#set-the-_primary_key_field-of-the-parent-model","title":"Set the <code>_primary_key_field</code> of the Parent Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the parent Model.</p> <p>Example</p> <p>In this case, there can be no two <code>Folder</code>'s with the same <code>path</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#register-the-models-in-the-store","title":"Register the Models in the Store","text":"<p>Then, in order for the store to know the existence of each given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#use-the-parent-model","title":"Use the Parent Model","text":"<p>Then you can use the parent model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Info</p> <p>The child models will be automatically inserted, or updated if they already exist</p> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#use-the-child-model-independently","title":"Use the Child Model Independently","text":"<p>You can also use the child model independently.</p> <p>Info</p> <p>Any mutation on the child model will also be reflected in the any parent model instances  fetched from redis after that mutation.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#indirectly-update-child-model","title":"Indirectly Update Child Model","text":"<p>A child model can be indirectly updated via the parent model.</p> <p>Set the attribute containing the child model list with a list of instances of the child model </p> <p>If there is any new instance of the child model that has a pre-existing primary key, it will be updated in redis.</p> <pre><code>import asyncio\nimport pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    await Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = await File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    await Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = await Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = await File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/list-of-nested-models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nparent folder:\n[   Folder(path='path/to/parent-folder', files=[File(path='path/to/bar.txt', type=&lt;FileType.TEXT: 'text'&gt;), File(path='path/to/bar.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)], folders=[Folder(path='path/to/child-folder', files=[File(path='path/to/foo.txt', type=&lt;FileType.TEXT: 'text'&gt;), File(path='path/to/foo.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)], folders=[])])]\n\nfiles:\n[   File(path='path/to/foo.txt', type=&lt;FileType.TEXT: 'text'&gt;),\n    File(path='path/to/foo.jpg', type=&lt;FileType.IMAGE: 'image'&gt;),\n    File(path='path/to/bar.txt', type=&lt;FileType.TEXT: 'text'&gt;),\n    File(path='path/to/bar.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)]\n\nindirectly updated parent folder:\n[   Folder(path='path/to/parent-folder', files=[File(path='path/to/bar.txt', type=&lt;FileType.TEXT: 'text'&gt;), File(path='path/to/bar.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)], folders=[Folder(path='path/to/child-folder', files=[File(path='path/to/foo.txt', type=&lt;FileType.EXEC: 'executable'&gt;)], folders=[])])]\n\nindirectly updated files:\n[File(path='path/to/foo.txt', type=&lt;FileType.EXEC: 'executable'&gt;)]\n</code></pre>"},{"location":"tutorials/asynchronous/models/","title":"Models","text":"<p>The very first thing you need to create for pydantic-redis are the models (or schemas) that the data you are to save in redis is to be based on.</p> <p>These models are derived from pydantic's <code>BaseModel</code>.</p>"},{"location":"tutorials/asynchronous/models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import pydantic-redis.asyncio's <code>Model</code></p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = await Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/models/#create-the-model","title":"Create the Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = await Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/models/#specify-the-_primary_key_field-attribute","title":"Specify the <code>_primary_key_field</code> Attribute","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two books with the same <code>title</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = await Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/models/#register-the-model-in-the-store","title":"Register the Model in the Store","text":"<p>Then, in order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = await Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/models/#use-the-model","title":"Use the Model","text":"<p>Then you can use the model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = await Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\n[   Book(title='Oliver Twist', author='Charles Dickens', rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False)]\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/","title":"Nested Models","text":"<p>The very first thing you need to create for pydantic-redis are the models (or schemas) that the data you are to save in redis is to be based on.</p> <p>It is possible to refer one model in another model in a parent-child relationship.</p>"},{"location":"tutorials/asynchronous/nested-models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import <code>pydantic-redis.asyncio</code>'s <code>Model</code>.</p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#create-the-child-model","title":"Create the Child Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#set-the-_primary_key_field-of-the-child-model","title":"Set the <code>_primary_key_field</code> of the Child Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two authors with the same <code>name</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#create-the-parent-model","title":"Create the Parent Model","text":"<p>Next, declare another model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes, as before.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#add-the-nested-model-to-the-parent-model","title":"Add the Nested Model to the Parent Model","text":"<p>Annotate the field that is to hold the child model with the child class. </p> <p>Example</p> <p>In this case, the field <code>author</code> is annotated with <code>Author</code> class.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#set-the-_primary_key_field-of-the-parent-model","title":"Set the <code>_primary_key_field</code> of the Parent Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the parent Model.</p> <p>Example</p> <p>In this case, there can be no two books with the same <code>title</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#register-the-models-in-the-store","title":"Register the Models in the Store","text":"<p>Then, in order for the store to know the existence of each given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#use-the-parent-model","title":"Use the Parent Model","text":"<p>Then you can use the parent model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Note</p> <p>The child model will be automatically inserted, or updated if it already exists</p> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#use-the-child-model-independently","title":"Use the Child Model Independently","text":"<p>You can also use the child model independently.</p> <p>Info</p> <p>Any mutation on the child model will also be reflected in the any parent model instances  fetched from redis after that mutation.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#indirectly-update-child-model","title":"Indirectly Update Child Model","text":"<p>A child model can be indirectly updated via the parent model.</p> <p>Set the attribute containing the child model with an instance of the child model</p> <p>Note</p> <p>The new instance of the child model should have the SAME primary key as the original child model.</p> <pre><code>import asyncio\nimport pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    await Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = await Book.select(ids=[\"Oliver Twist\"])\n    author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    await Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = await Book.select(ids=[\"Oliver Twist\"])\n\n    await Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = await Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/nested-models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nbook:\n[   Book(title='Oliver Twist', author=Author(name='Charles Dickens', active_years=(1999, 2007)), rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False)]\n\nauthor:\n[Author(name='Charles Dickens', active_years=(1999, 2007))]\n\nindirectly updated book:\n[   Book(title='Oliver Twist', author=Author(name='Charles Dickens', active_years=(1227, 1277)), rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False)]\n\nindirectly updated author:\n[Author(name='Charles Dickens', active_years=(1969, 1999))]\n</code></pre>"},{"location":"tutorials/asynchronous/select/","title":"Select","text":"<p>Pydantic-redis can be used to retrieve model instances from redis.</p>"},{"location":"tutorials/asynchronous/select/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code>.</p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = await Book.select()\n    select_by_id_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"]\n    )\n\n    select_some_fields_response = await Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = await Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = await Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/select/#select-all-records","title":"Select All Records","text":"<p>To select all records for the given model in redis, call the model's <code>select</code> method without any arguments.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = await Book.select()\n    select_by_id_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"]\n    )\n\n    select_some_fields_response = await Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = await Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = await Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/select/#select-some-fields-for-all-records","title":"Select Some Fields for All Records","text":"<p>To select some fields for all records for the given model in redis, pass the desired fields (<code>columns</code>) to the model's  <code>select</code> method.</p> <p>Info</p> <p>This returns dictionaries instead of Model instances.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = await Book.select()\n    select_by_id_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"]\n    )\n\n    select_some_fields_response = await Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = await Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = await Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/select/#select-some-records","title":"Select Some Records","text":"<p>To select some records for the given model in redis, pass a list of the primary keys (<code>ids</code>) of the desired records to  the model's <code>select</code> method.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = await Book.select()\n    select_by_id_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"]\n    )\n\n    select_some_fields_response = await Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = await Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = await Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/select/#select-some-fields-for-some-records","title":"Select Some Fields for Some Records","text":"<p>We can go further and limit the fields returned for the desired records.</p> <p>We pass the desired fields (<code>columns</code>) to the model's <code>select</code> method, together with the list of the primary keys  (<code>ids</code>) of the desired records.</p> <p>Info</p> <p>This returns dictionaries instead of Model instances.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = await Book.select()\n    select_by_id_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"]\n    )\n\n    select_some_fields_response = await Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = await Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = await Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/select/#select-records-page-by-page","title":"Select Records Page by Page","text":"<p>In order to avoid overwhelming the server's memory resources, we can get the records one page at a time i.e. pagination.</p> <p>We do this by specifying the number of records per page (<code>limit</code>) and the number of records to skip (<code>skip</code>)  when calling the model's <code>select</code> method</p> <p>Info</p> <p>Records are ordered by timestamp of their insert into redis. </p> <p>For batch inserts, the time difference is quite small but consistent. </p> <p>Tip</p> <p>You don't have to pass the <code>skip</code> if you wish to get the first records. <code>skip</code> defaults to 0.</p> <p><code>limit</code>, however is mandatory.</p> <p>Warning</p> <p>When both <code>ids</code> and <code>limit</code> are supplied, pagination is ignored. </p> <p>It wouldn't make any sense otherwise.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = await Book.select()\n    select_by_id_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"]\n    )\n\n    select_some_fields_response = await Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = await Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = await Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = await Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/select/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nall:\n[   Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Utah Blaine', author=\"Louis L'Amour\"),\n    Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\nby id:\n[   Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\nsome fields for all:\n[   {'author': 'Charles Dickens'},\n    {'author': \"Louis L'Amour\"},\n    {'author': 'Emily Bronte'},\n    {'author': 'Jane Austen'}]\n\nsome fields for given ids:\n[{'author': 'Charles Dickens'}, {'author': 'Jane Austen'}]\n\npaginated; skip: 0, limit: 2:\n[   Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Jane Eyre', author='Emily Bronte')]\n\npaginated returning some fields for each; skip: 2, limit: 2:\n[{'author': 'Jane Austen'}, {'author': \"Louis L'Amour\"}]\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/","title":"Tuples of Nested Models","text":"<p>Sometimes, one might need to have models (schemas) that have tuples of other models (schemas).</p> <p>An example is a <code>ScoreBoard</code> model that can have Tuples of player name and <code>Scores</code>'.</p> <p>This can easily be pulled off with pydantic-redis.</p>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import <code>pydantic-redis.asyncio</code>'s <code>Model</code>.</p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#create-the-child-model","title":"Create the Child Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#set-the-_primary_key_field-of-the-child-model","title":"Set the <code>_primary_key_field</code> of the Child Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two <code>Score</code>'s with the same <code>id</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#create-the-parent-model","title":"Create the Parent Model","text":"<p>Next, declare another model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes, as before.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#add-the-nested-model-tuple-to-the-parent-model","title":"Add the Nested Model Tuple to the Parent Model","text":"<p>Annotate the field that is to hold the tuple of child models with the Tuple of child class. </p> <p>Example</p> <p>In this case, the field <code>scores</code> is annotated with <code>Tuple[str, Score]</code> class.</p> <p>Info</p> <p>The <code>str</code> is the player's name.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#set-the-_primary_key_field-of-the-parent-model","title":"Set the <code>_primary_key_field</code> of the Parent Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the parent Model.</p> <p>Example</p> <p>In this case, there can be no two <code>ScoreBoard</code>'s with the same <code>id</code>.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#register-the-models-in-the-store","title":"Register the Models in the Store","text":"<p>Then, in order for the store to know the existence of each given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#use-the-parent-model","title":"Use the Parent Model","text":"<p>Then you can use the parent model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Info</p> <p>The child models will be automatically inserted, or updated if they already exist</p> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#use-the-child-model-independently","title":"Use the Child Model Independently","text":"<p>You can also use the child model independently.</p> <p>Info</p> <p>Any mutation on the child model will also be reflected in the any parent model instances  fetched from redis after that mutation.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#indirectly-update-child-model","title":"Indirectly Update Child Model","text":"<p>A child model can be indirectly updated via the parent model.</p> <p>Set the attribute containing the child model tuple with a tuple of instances of the child model </p> <p>If there is any new instance of the child model that has a pre-existing primary key, it will be updated in redis.</p> <pre><code>import asyncio\nimport pprint\nfrom typing import Tuple\nfrom pydantic_redis.asyncio import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    await ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = await ScoreBoard.select(ids=[\"test\"])\n    scores_response = await Score.select(ids=[\"some id\"])\n\n    await Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = await ScoreBoard.select(ids=[\"test\"])\n\n    await ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = await Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/tuple-of-nested-models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nscore board:\n[ScoreBoard(id='test', scores=('mark', Score(id='some id', total=50)))]\n\nscores:\n[Score(id='some id', total=50)]\n\nindirectly updated score board:\n[ScoreBoard(id='test', scores=('mark', Score(id='some id', total=78)))]\n\nindirectly updated score:\n[Score(id='some id', total=60)]\n</code></pre>"},{"location":"tutorials/asynchronous/update/","title":"Update","text":"<p>Pydantic-redis can be used to update model instances in redis.</p>"},{"location":"tutorials/asynchronous/update/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code>.</p> <p>Warning</p> <p>The imports are from <code>pydantic_redis.asyncio</code> NOT <code>pydantic_redis</code></p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    await Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = await Book.select()\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = await Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/update/#update-one-record","title":"Update One Record","text":"<p>To update a single record in redis, pass the primary key (<code>_id</code>) of that record and the new changes to the model's <code>update</code>  method</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    await Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = await Book.select()\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = await Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/update/#update-one-record-with-ttl","title":"Update One Record With TTL","text":"<p>To update the record's time-to-live (TTL) also, pass the <code>life_span_seconds</code> argument to the model's <code>update</code> method.</p> <p>Info</p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used.</p> <p>The <code>life_span_in_seconds</code> in both cases is <code>None</code> by default. This means records never expire by default.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    await Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = await Book.select()\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = await Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/update/#updateupsert-many-records","title":"Update/Upsert Many Records","text":"<p>To update many records in redis, pass a list of that model's instances as first argument to the model's <code>insert</code> method.</p> <p>Technically, this will insert any records that don't exist and overwrite any that exist already.</p> <p>Info</p> <p>Updating many records at once is more performant than adding one record at a time repeatedly because less network requests are made in the former.</p> <p>Warning</p> <p>Calling <code>insert</code> always overwrites the time-to-live of the records updated. </p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used. </p> <p>By default <code>life_span_seconds</code> is <code>None</code> i.e. the time-to-live is removed and the updated records never expire.</p> <pre><code>import asyncio\nimport pprint\nfrom pydantic_redis.asyncio import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nasync def main():\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    await Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    await Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = await Book.select()\n\n    await Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = await Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n</code></pre>"},{"location":"tutorials/asynchronous/update/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nsingle update:\n[   Book(title='Jane Eyre', author='Daniel McKenzie'),\n    Book(title='Oliver Twist', author='Charlie Ickens'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\nmulti update:\n[   Book(title='Jane Eyre', author='Emiliano Bronte'),\n    Book(title='Oliver Twist', author='Chuck Dickens'),\n    Book(title='Pride and Prejudice', author='Janey Austen')]\n</code></pre>"},{"location":"tutorials/synchronous/delete/","title":"Delete","text":"<p>Pydantic-redis can be used to delete model instances from redis.</p>"},{"location":"tutorials/synchronous/delete/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n    pre_delete_response = Book.select()\n\n    Book.delete(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n    post_delete_response = Book.select()\n\n    print(\"pre-delete:\")\n    pp.pprint(pre_delete_response)\n\n    print(\"\\npost-delete:\")\n    pp.pprint(post_delete_response)\n</code></pre>"},{"location":"tutorials/synchronous/delete/#delete-records","title":"Delete Records","text":"<p>To delete many records from redis, pass a list of primary keys (<code>ids</code>) of the records to the model's <code>delete</code> method.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n    pre_delete_response = Book.select()\n\n    Book.delete(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n    post_delete_response = Book.select()\n\n    print(\"pre-delete:\")\n    pp.pprint(pre_delete_response)\n\n    print(\"\\npost-delete:\")\n    pp.pprint(post_delete_response)\n</code></pre>"},{"location":"tutorials/synchronous/delete/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\npre-delete:\n[   Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Utah Blaine', author=\"Louis L'Amour\"),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\npost-delete:\n[   Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Utah Blaine', author=\"Louis L'Amour\")]\n</code></pre>"},{"location":"tutorials/synchronous/insert/","title":"Insert","text":"<p>Pydantic-redis can be used to insert new model instances into redis.</p>"},{"location":"tutorials/synchronous/insert/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = Book.select()\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/insert/#insert-one-record","title":"Insert One Record","text":"<p>To add a single record to the redis instance, pass that model's instance as first argument to the model's <code>insert</code>  method</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = Book.select()\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/insert/#insert-one-record-with-ttl","title":"Insert One Record With TTL","text":"<p>To make the record added to redis temporary, add a <code>life_span_seconds</code> (Time To Live i.e. TTL) key-word argument  when calling the model's <code>insert</code> method.</p> <p>Info</p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used.</p> <p>The <code>life_span_in_seconds</code> in both cases is <code>None</code> by default. This means records never expire by default.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = Book.select()\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/insert/#insert-many-records","title":"Insert Many Records","text":"<p>To add many records to the redis instance, pass a list of that model's instances as first argument to the model's <code>insert</code> method.</p> <p>Info</p> <p>Adding many records at once is more performant than adding one record at a time repeatedly because less network requests are made in the former.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = Book.select()\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/insert/#insert-many-records-with-ttl","title":"Insert Many Records With TTL","text":"<p>To add temporary records to redis, add a <code>life_span_seconds</code> (Time To Live i.e. TTL) argument  when calling the model's <code>insert</code> method.</p> <p>Info</p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used.</p> <p>The <code>life_span_in_seconds</code> in both cases is <code>None</code> by default. This means records never expire by default.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(Book(title=\"Oliver Twist\", author=\"Charles Dickens\"))\n    Book.insert(\n        Book(title=\"Great Expectations\", author=\"Charles Dickens\"),\n        life_span_seconds=1800,\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.insert(\n        [\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n\n    response = Book.select()\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/insert/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\n[   Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Great Expectations', author='Charles Dickens'),\n    Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/","title":"Lists of Nested Models","text":"<p>Sometimes, one might need to have models (schemas) that have lists of other models (schemas).</p> <p>An example is a <code>Folder</code> model that can have child <code>Folder</code>'s and <code>File</code>'s.</p> <p>This can easily be pulled off with pydantic-redis.</p>"},{"location":"tutorials/synchronous/list-of-nested-models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import pydantic-redis' <code>Model</code></p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#create-the-child-model","title":"Create the Child Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#set-the-_primary_key_field-of-the-child-model","title":"Set the <code>_primary_key_field</code> of the Child Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two <code>File</code>'s with the same <code>path</code>.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#create-the-parent-model","title":"Create the Parent Model","text":"<p>Next, declare another model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes, as before.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#add-the-nested-model-list-to-the-parent-model","title":"Add the Nested Model List to the Parent Model","text":"<p>Annotate the field that is to hold the child model list with the List of child class. </p> <p>Example</p> <p>In this case, the field <code>files</code> is annotated with <code>List[File]</code>.</p> <p>And the field <code>folders</code> is annotated with <code>\"Folder\"</code> class i.e. itself.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#set-the-_primary_key_field-of-the-parent-model","title":"Set the <code>_primary_key_field</code> of the Parent Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the parent Model.</p> <p>Example</p> <p>In this case, there can be no two <code>Folder</code>'s with the same <code>path</code>.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#register-the-models-in-the-store","title":"Register the Models in the Store","text":"<p>Then, in order for the store to know the existence of each given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#use-the-parent-model","title":"Use the Parent Model","text":"<p>Then you can use the parent model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Info</p> <p>The child models will be automatically inserted, or updated if they already exist</p> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#use-the-child-model-independently","title":"Use the Child Model Independently","text":"<p>You can also use the child model independently.</p> <p>Info</p> <p>Any mutation on the child model will also be reflected in the any parent model instances  fetched from redis after that mutation.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#indirectly-update-child-model","title":"Indirectly Update Child Model","text":"<p>A child model can be indirectly updated via the parent model.</p> <p>Set the attribute containing the child model list with a list of instances of the child model </p> <p>If there is any new instance of the child model that has a pre-existing primary key, it will be updated in redis.</p> <pre><code>import pprint\nfrom enum import Enum\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass FileType(Enum):\n    TEXT = \"text\"\n    IMAGE = \"image\"\n    EXEC = \"executable\"\n\n\nclass File(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    type: FileType\n\n\nclass Folder(Model):\n    _primary_key_field: str = \"path\"\n    path: str\n    files: List[File] = []\n    folders: List[\"Folder\"] = []\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(File)\n    store.register_model(Folder)\n\n    child_folder = Folder(\n        path=\"path/to/child-folder\",\n        files=[\n            File(path=\"path/to/foo.txt\", type=FileType.TEXT),\n            File(path=\"path/to/foo.jpg\", type=FileType.IMAGE),\n        ],\n    )\n\n    Folder.insert(\n        Folder(\n            path=\"path/to/parent-folder\",\n            files=[\n                File(path=\"path/to/bar.txt\", type=FileType.TEXT),\n                File(path=\"path/to/bar.jpg\", type=FileType.IMAGE),\n            ],\n            folders=[child_folder],\n        )\n    )\n\n    parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    files_response = File.select(\n        ids=[\"path/to/foo.txt\", \"path/to/foo.jpg\", \"path/to/bar.txt\", \"path/to/bar.jpg\"]\n    )\n\n    Folder.update(\n        _id=\"path/to/child-folder\",\n        data={\"files\": [File(path=\"path/to/foo.txt\", type=FileType.EXEC)]},\n    )\n    updated_parent_folder_response = Folder.select(ids=[\"path/to/parent-folder\"])\n    updated_file_response = File.select(ids=[\"path/to/foo.txt\"])\n\n    print(\"parent folder:\")\n    pp.pprint(parent_folder_response)\n    print(\"\\nfiles:\")\n    pp.pprint(files_response)\n\n    print(\"\\nindirectly updated parent folder:\")\n    pp.pprint(updated_parent_folder_response)\n    print(\"\\nindirectly updated files:\")\n    pp.pprint(updated_file_response)\n</code></pre>"},{"location":"tutorials/synchronous/list-of-nested-models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nparent folder:\n[   Folder(path='path/to/parent-folder', files=[File(path='path/to/bar.txt', type=&lt;FileType.TEXT: 'text'&gt;), File(path='path/to/bar.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)], folders=[Folder(path='path/to/child-folder', files=[File(path='path/to/foo.txt', type=&lt;FileType.TEXT: 'text'&gt;), File(path='path/to/foo.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)], folders=[])])]\n\nfiles:\n[   File(path='path/to/foo.txt', type=&lt;FileType.TEXT: 'text'&gt;),\n    File(path='path/to/foo.jpg', type=&lt;FileType.IMAGE: 'image'&gt;),\n    File(path='path/to/bar.txt', type=&lt;FileType.TEXT: 'text'&gt;),\n    File(path='path/to/bar.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)]\n\nindirectly updated parent folder:\n[   Folder(path='path/to/parent-folder', files=[File(path='path/to/bar.txt', type=&lt;FileType.TEXT: 'text'&gt;), File(path='path/to/bar.jpg', type=&lt;FileType.IMAGE: 'image'&gt;)], folders=[Folder(path='path/to/child-folder', files=[File(path='path/to/foo.txt', type=&lt;FileType.EXEC: 'executable'&gt;)], folders=[])])]\n\nindirectly updated files:\n[File(path='path/to/foo.txt', type=&lt;FileType.EXEC: 'executable'&gt;)]\n</code></pre>"},{"location":"tutorials/synchronous/models/","title":"Models","text":"<p>The very first thing you need to create for pydantic-redis are the models (or schemas) that the data you are to save in redis is to be based on.</p> <p>These models are derived from pydantic's <code>BaseModel</code>.</p>"},{"location":"tutorials/synchronous/models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import pydantic-redis' <code>Model</code></p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/models/#create-the-model","title":"Create the Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/models/#specify-the-_primary_key_field-attribute","title":"Specify the <code>_primary_key_field</code> Attribute","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two books with the same <code>title</code>.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/models/#register-the-model-in-the-store","title":"Register the Model in the Store","text":"<p>Then, in order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/models/#use-the-model","title":"Use the Model","text":"<p>Then you can use the model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=\"Charles Dickens\",\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    response = Book.select(ids=[\"Oliver Twist\"])\n    pp.pprint(response)\n</code></pre>"},{"location":"tutorials/synchronous/models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\n[   Book(title='Oliver Twist', author='Charles Dickens', rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False)]\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/","title":"Nested Models","text":"<p>The very first thing you need to create for pydantic-redis are the models (or schemas) that the data you are to save in redis is to be based on.</p> <p>It is possible to refer one model in another model in a parent-child relationship.</p>"},{"location":"tutorials/synchronous/nested-models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import pydantic-redis' <code>Model</code></p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#create-the-child-model","title":"Create the Child Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#set-the-_primary_key_field-of-the-child-model","title":"Set the <code>_primary_key_field</code> of the Child Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two authors with the same <code>name</code>.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#create-the-parent-model","title":"Create the Parent Model","text":"<p>Next, declare another model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes, as before.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#add-the-nested-model-to-the-parent-model","title":"Add the Nested Model to the Parent Model","text":"<p>Annotate the field that is to hold the child model with the child class. </p> <p>Example</p> <p>In this case, the field <code>author</code> is annotated with <code>Author</code> class.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#set-the-_primary_key_field-of-the-parent-model","title":"Set the <code>_primary_key_field</code> of the Parent Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the parent Model.</p> <p>Example</p> <p>In this case, there can be no two books with the same <code>title</code>.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#register-the-models-in-the-store","title":"Register the Models in the Store","text":"<p>Then, in order for the store to know the existence of each given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#use-the-parent-model","title":"Use the Parent Model","text":"<p>Then you can use the parent model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Note</p> <p>The child model will be automatically inserted, or updated if it already exists</p> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#use-the-child-model-independently","title":"Use the Child Model Independently","text":"<p>You can also use the child model independently.</p> <p>Info</p> <p>Any mutation on the child model will also be reflected in the any parent model instances  fetched from redis after that mutation.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#indirectly-update-child-model","title":"Indirectly Update Child Model","text":"<p>A child model can be indirectly updated via the parent model.</p> <p>Set the attribute containing the child model with an instance of the child model</p> <p>Note</p> <p>The new instance of the child model should have the SAME primary key as the original child model.</p> <pre><code>import pprint\nfrom datetime import date\nfrom typing import List, Tuple\n\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Author(Model):\n    _primary_key_field: str = \"name\"\n    name: str\n    active_years: Tuple[int, int]\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: Author\n    rating: float\n    published_on: date\n    tags: List[str] = []\n    in_stock: bool = True\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\",\n        redis_config=RedisConfig(db=5, host=\"localhost\", port=6379),\n        life_span_in_seconds=3600,\n    )\n\n    store.register_model(Author)\n    store.register_model(Book)\n\n    Book.insert(\n        Book(\n            title=\"Oliver Twist\",\n            author=Author(name=\"Charles Dickens\", active_years=(1999, 2007)),\n            published_on=date(year=1215, month=4, day=4),\n            in_stock=False,\n            rating=2,\n            tags=[\"Classic\"],\n        )\n    )\n\n    book_response = Book.select(ids=[\"Oliver Twist\"])\n    author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    Author.update(_id=\"Charles Dickens\", data={\"active_years\": (1227, 1277)})\n    updated_book_response = Book.select(ids=[\"Oliver Twist\"])\n\n    Book.update(\n        _id=\"Oliver Twist\",\n        data={\"author\": Author(name=\"Charles Dickens\", active_years=(1969, 1999))},\n    )\n    updated_author_response = Author.select(ids=[\"Charles Dickens\"])\n\n    print(\"book:\")\n    pp.pprint(book_response)\n    print(\"\\nauthor:\")\n    pp.pprint(author_response)\n\n    print(\"\\nindirectly updated book:\")\n    pp.pprint(updated_book_response)\n    print(\"\\nindirectly updated author:\")\n    pp.pprint(updated_author_response)\n</code></pre>"},{"location":"tutorials/synchronous/nested-models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nbook:\n[   Book(title='Oliver Twist', author=Author(name='Charles Dickens', active_years=(1999, 2007)), rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False)]\n\nauthor:\n[Author(name='Charles Dickens', active_years=(1999, 2007))]\n\nindirectly updated book:\n[   Book(title='Oliver Twist', author=Author(name='Charles Dickens', active_years=(1227, 1277)), rating=2.0, published_on=datetime.date(1215, 4, 4), tags=['Classic'], in_stock=False)]\n\nindirectly updated author:\n[Author(name='Charles Dickens', active_years=(1969, 1999))]\n</code></pre>"},{"location":"tutorials/synchronous/select/","title":"Select","text":"<p>Pydantic-redis can be used to retrieve model instances from redis.</p>"},{"location":"tutorials/synchronous/select/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = Book.select()\n    select_by_id_response = Book.select(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n\n    select_some_fields_response = Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n</code></pre>"},{"location":"tutorials/synchronous/select/#select-all-records","title":"Select All Records","text":"<p>To select all records for the given model in redis, call the model's <code>select</code> method without any arguments.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = Book.select()\n    select_by_id_response = Book.select(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n\n    select_some_fields_response = Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n</code></pre>"},{"location":"tutorials/synchronous/select/#select-some-fields-for-all-records","title":"Select Some Fields for All Records","text":"<p>To select some fields for all records for the given model in redis, pass the desired fields (<code>columns</code>) to the model's  <code>select</code> method.</p> <p>Info</p> <p>This returns dictionaries instead of Model instances.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = Book.select()\n    select_by_id_response = Book.select(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n\n    select_some_fields_response = Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n</code></pre>"},{"location":"tutorials/synchronous/select/#select-some-records","title":"Select Some Records","text":"<p>To select some records for the given model in redis, pass a list of the primary keys (<code>ids</code>) of the desired records to  the model's <code>select</code> method.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = Book.select()\n    select_by_id_response = Book.select(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n\n    select_some_fields_response = Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n</code></pre>"},{"location":"tutorials/synchronous/select/#select-some-fields-for-some-records","title":"Select Some Fields for Some Records","text":"<p>We can go further and limit the fields returned for the desired records.</p> <p>We pass the desired fields (<code>columns</code>) to the model's <code>select</code> method, together with the list of the primary keys  (<code>ids</code>) of the desired records.</p> <p>Info</p> <p>This returns dictionaries instead of Model instances.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = Book.select()\n    select_by_id_response = Book.select(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n\n    select_some_fields_response = Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n</code></pre>"},{"location":"tutorials/synchronous/select/#select-records-page-by-page","title":"Select Records Page by Page","text":"<p>In order to avoid overwhelming the server's memory resources, we can get the records one page at a time i.e. pagination.</p> <p>We do this by specifying the number of records per page (<code>limit</code>) and the number of records to skip (<code>skip</code>)  when calling the model's <code>select</code> method</p> <p>Info</p> <p>Records are ordered by timestamp of their insert into redis. </p> <p>For batch inserts, the time difference is quite small but consistent. </p> <p>Tip</p> <p>You don't have to pass the <code>skip</code> if you wish to get the first records. <code>skip</code> defaults to 0.</p> <p><code>limit</code>, however is mandatory.</p> <p>Warning</p> <p>When both <code>ids</code> and <code>limit</code> are supplied, pagination is ignored. </p> <p>It wouldn't make any sense otherwise.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n            Book(title=\"Utah Blaine\", author=\"Louis L'Amour\"),\n        ]\n    )\n\n    select_all_response = Book.select()\n    select_by_id_response = Book.select(ids=[\"Oliver Twist\", \"Pride and Prejudice\"])\n\n    select_some_fields_response = Book.select(columns=[\"author\"])\n    select_some_fields_for_ids_response = Book.select(\n        ids=[\"Oliver Twist\", \"Pride and Prejudice\"], columns=[\"author\"]\n    )\n\n    paginated_select_all_response = Book.select(skip=0, limit=2)\n    paginated_select_some_fields_response = Book.select(\n        columns=[\"author\"], skip=2, limit=2\n    )\n\n    print(\"all:\")\n    pp.pprint(select_all_response)\n    print(\"\\nby id:\")\n    pp.pprint(select_by_id_response)\n    print(\"\\nsome fields for all:\")\n    pp.pprint(select_some_fields_response)\n    print(\"\\nsome fields for given ids:\")\n    pp.pprint(select_some_fields_for_ids_response)\n    print(\"\\npaginated; skip: 0, limit: 2:\")\n    pp.pprint(paginated_select_all_response)\n    print(\"\\npaginated returning some fields for each; skip: 2, limit: 2:\")\n    pp.pprint(paginated_select_some_fields_response)\n</code></pre>"},{"location":"tutorials/synchronous/select/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nall:\n[   Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Utah Blaine', author=\"Louis L'Amour\"),\n    Book(title='Jane Eyre', author='Emily Bronte'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\nby id:\n[   Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\nsome fields for all:\n[   {'author': 'Charles Dickens'},\n    {'author': \"Louis L'Amour\"},\n    {'author': 'Emily Bronte'},\n    {'author': 'Jane Austen'}]\n\nsome fields for given ids:\n[{'author': 'Charles Dickens'}, {'author': 'Jane Austen'}]\n\npaginated; skip: 0, limit: 2:\n[   Book(title='Oliver Twist', author='Charles Dickens'),\n    Book(title='Jane Eyre', author='Emily Bronte')]\n\npaginated returning some fields for each; skip: 2, limit: 2:\n[{'author': 'Jane Austen'}, {'author': \"Louis L'Amour\"}]\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/","title":"Tuples of Nested Models","text":"<p>Sometimes, one might need to have models (schemas) that have tuples of other models (schemas).</p> <p>An example is a <code>ScoreBoard</code> model that can have Tuples of player name and <code>Scores</code>'.</p> <p>This can easily be pulled off with pydantic-redis.</p>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#import-pydantic-redis-model","title":"Import Pydantic-redis' <code>Model</code>","text":"<p>First, import pydantic-redis' <code>Model</code></p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#create-the-child-model","title":"Create the Child Model","text":"<p>Next, declare a new model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#set-the-_primary_key_field-of-the-child-model","title":"Set the <code>_primary_key_field</code> of the Child Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the Model.</p> <p>Example</p> <p>In this case, there can be no two <code>Score</code>'s with the same <code>id</code>.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#create-the-parent-model","title":"Create the Parent Model","text":"<p>Next, declare another model as a class that inherits from <code>Model</code>.</p> <p>Use standard Python types for all attributes, as before.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#add-the-nested-model-tuple-to-the-parent-model","title":"Add the Nested Model Tuple to the Parent Model","text":"<p>Annotate the field that is to hold the tuple of child models with the Tuple of child class. </p> <p>Example</p> <p>In this case, the field <code>scores</code> is annotated with <code>Tuple[str, Score]</code> class.</p> <p>Info</p> <p>The <code>str</code> is the player's name.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#set-the-_primary_key_field-of-the-parent-model","title":"Set the <code>_primary_key_field</code> of the Parent Model","text":"<p>Set the <code>_primary_key_field</code> attribute to the name of the attribute that is to act as a unique identifier for each instance of the parent Model.</p> <p>Example</p> <p>In this case, there can be no two <code>ScoreBoard</code>'s with the same <code>id</code>.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#register-the-models-in-the-store","title":"Register the Models in the Store","text":"<p>Then, in order for the store to know the existence of each given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#use-the-parent-model","title":"Use the Parent Model","text":"<p>Then you can use the parent model class to:</p> <ul> <li><code>insert</code> into the store</li> <li><code>update</code> an instance of the model</li> <li><code>delete</code> from store</li> <li><code>select</code> from store</li> </ul> <p>Info</p> <p>The child models will be automatically inserted, or updated if they already exist</p> <p>Info</p> <p>The store is connected to the Redis instance, so any changes you make will reflect in redis itself.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#use-the-child-model-independently","title":"Use the Child Model Independently","text":"<p>You can also use the child model independently.</p> <p>Info</p> <p>Any mutation on the child model will also be reflected in the any parent model instances  fetched from redis after that mutation.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#indirectly-update-child-model","title":"Indirectly Update Child Model","text":"<p>A child model can be indirectly updated via the parent model.</p> <p>Set the attribute containing the child model tuple with a tuple of instances of the child model </p> <p>If there is any new instance of the child model that has a pre-existing primary key, it will be updated in redis.</p> <pre><code>import pprint\nfrom typing import Tuple\nfrom pydantic_redis import RedisConfig, Model, Store\n\n\nclass Score(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    total: int\n\n\nclass ScoreBoard(Model):\n    _primary_key_field: str = \"id\"\n    id: str\n    scores: Tuple[str, Score]\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(name=\"test\", redis_config=RedisConfig())\n\n    store.register_model(Score)\n    store.register_model(ScoreBoard)\n\n    ScoreBoard.insert(\n        data=ScoreBoard(\n            id=\"test\",\n            scores=(\n                \"mark\",\n                Score(id=\"some id\", total=50),\n            ),\n        )\n    )\n    score_board_response = ScoreBoard.select(ids=[\"test\"])\n    scores_response = Score.select(ids=[\"some id\"])\n\n    Score.update(_id=\"some id\", data={\"total\": 78})\n    updated_score_board_response = ScoreBoard.select(ids=[\"test\"])\n\n    ScoreBoard.update(\n        _id=\"test\",\n        data={\n            \"scores\": (\n                \"tom\",\n                Score(id=\"some id\", total=60),\n            )\n        },\n    )\n    updated_score_response = Score.select(ids=[\"some id\"])\n\n    print(\"score board:\")\n    pp.pprint(score_board_response)\n    print(\"\\nscores:\")\n    pp.pprint(scores_response)\n\n    print(\"\\nindirectly updated score board:\")\n    pp.pprint(updated_score_board_response)\n    print(\"\\nindirectly updated score:\")\n    pp.pprint(updated_score_response)\n</code></pre>"},{"location":"tutorials/synchronous/tuple-of-nested-models/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nscore board:\n[ScoreBoard(id='test', scores=('mark', Score(id='some id', total=50)))]\n\nscores:\n[Score(id='some id', total=50)]\n\nindirectly updated score board:\n[ScoreBoard(id='test', scores=('mark', Score(id='some id', total=78)))]\n\nindirectly updated score:\n[Score(id='some id', total=60)]\n</code></pre>"},{"location":"tutorials/synchronous/update/","title":"Update","text":"<p>Pydantic-redis can be used to update model instances in redis.</p>"},{"location":"tutorials/synchronous/update/#create-and-register-the-model","title":"Create and register the Model","text":"<p>A model is a class that inherits from <code>Model</code> with its <code>_primary_key_field</code> attribute set.</p> <p>In order for the store to know the existence of the given model,  register it using the <code>register_model</code> method of <code>Store</code></p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = Book.select()\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n</code></pre>"},{"location":"tutorials/synchronous/update/#update-one-record","title":"Update One Record","text":"<p>To update a single record in redis, pass the primary key (<code>_id</code>) of that record and the new changes to the model's <code>update</code>  method</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = Book.select()\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n</code></pre>"},{"location":"tutorials/synchronous/update/#update-one-record-with-ttl","title":"Update One Record With TTL","text":"<p>To update the record's time-to-live (TTL) also, pass the <code>life_span_seconds</code> argument to the model's <code>update</code> method.</p> <p>Info</p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used.</p> <p>The <code>life_span_in_seconds</code> in both cases is <code>None</code> by default. This means records never expire by default.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = Book.select()\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n</code></pre>"},{"location":"tutorials/synchronous/update/#updateupsert-many-records","title":"Update/Upsert Many Records","text":"<p>To update many records in redis, pass a list of that model's instances as first argument to the model's <code>insert</code> method.</p> <p>Technically, this will insert any records that don't exist and overwrite any that exist already.</p> <p>Info</p> <p>Updating many records at once is more performant than adding one record at a time repeatedly because less network requests are made in the former.</p> <p>Warning</p> <p>Calling <code>insert</code> always overwrites the time-to-live of the records updated. </p> <p>When the <code>life_span_seconds</code> argument is not specified, the <code>life_span_in_seconds</code> passed to the store during initialization is used. </p> <p>By default <code>life_span_seconds</code> is <code>None</code> i.e. the time-to-live is removed and the updated records never expire.</p> <pre><code>import pprint\nfrom pydantic_redis import Model, Store, RedisConfig\n\n\nclass Book(Model):\n    _primary_key_field: str = \"title\"\n    title: str\n    author: str\n\n\nif __name__ == \"__main__\":\n    pp = pprint.PrettyPrinter(indent=4)\n    store = Store(\n        name=\"some_name\", redis_config=RedisConfig(), life_span_in_seconds=86400\n    )\n\n    store.register_model(Book)\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Charles Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emily Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Jane Austen\"),\n        ]\n    )\n    Book.update(_id=\"Oliver Twist\", data={\"author\": \"Charlie Ickens\"})\n    Book.update(\n        _id=\"Jane Eyre\", data={\"author\": \"Daniel McKenzie\"}, life_span_seconds=1800\n    )\n    single_update_response = Book.select()\n\n    Book.insert(\n        [\n            Book(title=\"Oliver Twist\", author=\"Chuck Dickens\"),\n            Book(title=\"Jane Eyre\", author=\"Emiliano Bronte\"),\n            Book(title=\"Pride and Prejudice\", author=\"Janey Austen\"),\n        ],\n        life_span_seconds=3600,\n    )\n    multi_update_response = Book.select()\n\n    print(\"single update:\")\n    pp.pprint(single_update_response)\n\n    print(\"\\nmulti update:\")\n    pp.pprint(multi_update_response)\n</code></pre>"},{"location":"tutorials/synchronous/update/#run-the-app","title":"Run the App","text":"<p>Running the above code in a file <code>main.py</code> would produce:</p> <p>Tip</p> <p>Probably FLUSHALL redis first</p> <pre><code>$ python main.py\nsingle update:\n[   Book(title='Jane Eyre', author='Daniel McKenzie'),\n    Book(title='Oliver Twist', author='Charlie Ickens'),\n    Book(title='Pride and Prejudice', author='Jane Austen')]\n\nmulti update:\n[   Book(title='Jane Eyre', author='Emiliano Bronte'),\n    Book(title='Oliver Twist', author='Chuck Dickens'),\n    Book(title='Pride and Prejudice', author='Janey Austen')]\n</code></pre>"}]}